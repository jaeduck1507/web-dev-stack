/*
    DDL(Data Definition Language) : 데이터 정의어
    - 실제 데이터 값이 아닌 구조 자체를 정의하는 언어
    - 객체(스키마)를 만들고 (CREATE), 변경하고 (ALTER), 삭제하는 (DROP)하는 언어
    -DB 관리자, 설계자 사용
    오라클에서 객체(구조) / 스키마(Schema) : 테이블(TABLE), 뷰(VIEW), 시퀀스(SEQUENCE), 인덱스(INDEX), 
    패키지(PACKAGE), 트리거(TRIGGER), 프로시저(PROCEDURE), 함수(FUNCTION), 동의어(SYNONYM), 사용자(USER)
*/

/*
    CREATE
    - 객체를 생성하는 구문
    
    테이블 생성
    테이블이란?  행(ROW)과 열(COLUMN)로 구성되는 가장 기본적인 데이터베이스 객체
                데이터베이스 내에 모든 데이터는 테이블에 저장됨
                
    CREATE TABLE 테이블명(
        컬럼명 자료형(크기),
        컬럼명 자료형(크기),
        ...
    );
    
    *자료형
    1. 문자(CHAR/VARCHAR2) - 반드시 크기를 지정해야 함
        - CHAR : 최대 2000BYTE까지 저장 가능
                 고정 길이 (아무리 작은 값이 들어와도 처음 할당된 크기 그대로)
                 고정된 글자수의 데이터만 담길 때 사용
        - VARCHAR2 : 최대 4000BYTE까지 저장 가능
                     가변 길이 (담긴 값에 따라서 공간의 크기 맞춰줌)
                     몇 글자의 데이터가 들어올지 모를 경우 사용
    2. 숫자(NUMBER)
    3. 날짜(DATE)
*/

-- 회원에 대한 데이터를 담는 MEMBER 테이블 생성
CREATE TABLE MEMBER(
    MEM_NO NUMBER,
    MEM_ID VARCHAR2(20),
    MEM_PWD VARCHAR2(20),
    MEM_NAME VARCHAR2(20),
    GENDER CHAR(3),
    PHONE VARCHAR2(13),
    EMAIL VARCHAR2(50),
    MEM_DATE DATE
);

-- 테이블 구조를 표시
DESC MEMBER;
/*
    데이터 딕셔너리
        - 다양한 객체들의 정보를 저장하고 있는 시스템 테이블
        - 사용자가 객체를 생성하거나 객체를 변경하는 등의 작업을 할 때 데이터베이스 서버에 의해서 자동으로 갱신되는 테이블
*/
-- USER_TABLES : 사용자가 가지고 있는 테이블들의 전반적인 구조를 확인할 수 있는 시스템 테이블
SELECT * FROM USER_TABLES;
-- USER_TAB_COLUMNS : 사용자가 가지고 있는 테이블들 상의 모든 컬럼의 전반적인 구조를 확인할 수 있는 시스템 테이블
SELECT * FROM USER_TAB_COLUMNS;

/*
    컬럼 주석
    - 테이블 컬럼에 대한 설명을 작성할 수 있는 구문
    
    COMMENT ON COLUMN 테이블명.컬럼명 IS '주석내용';
*/
COMMENT ON COLUMN MEMBER.MEM_ID IS '회원번호';

-- 테이블에 데이터를 추가시키는 구문 (DML : INSERT)
-- INSERT INTO 테이블명 VALUES(값, 값, 값, ...);
INSERT INTO MEMBER VALUES(1,'USER01','PASS01','윤의진','남','010-1111-2222','aaa@naver.com','25/06/05');
INSERT INTO MEMBER(MEM_NO,MEM_ID,MEM_PWD,MEM_NAME) VALUES(2,'USER02','PASS02','이진용');
INSERT INTO MEMBER VALUES(NULL, NULL, NULL, NULL,NULL,NULL,NULL,NULL);
SELECT * FROM MEMBER;

/*
    제약조건(CONSTRAINTS)
    - 사용자가 원하는 조건의 데이터만 유지하기 위해서 각 컬럼에 대해 저장될 값에 대한 제약조건을 설정
    - 제약조건은 데이터 무결성 보장을 목적으로 한다. (데이터의 정확성과 일관성을 유지시키는 것)
    - 종류 : NOT NULL, UNIQUE, CHECK, PRIMARY KEY FOREIGN KEY
    
    CREATE TABLE 테이블명(
        컬럼명 자료형(크기) [COSTRAINTS 제약조건명] 제약조건,
        ...
    );
*/
/*
    NOT NULL 제약조건
    - 해당 컬럼에 반드시 값이 존재해야만 하는 경우 (즉, 해당 컬럼에 NULL이 들어와서는 안되는 경우)
    - 추가/ 수정 시 NULL 값을 허용하지 않도록 제한
*/
CREATE TABLE MEM_NOTNULL(
    MEM_NO NUMBER NOT NULL,
    MEM_ID VARCHAR2(20) NOT NULL,
    MEM_PWD VARCHAR2(20) NOT NULL,
    MEM_NAME VARCHAR2(20) NOT NULL,
    GENDER CHAR(3),
    PHONE VARCHAR2(13),
    EMAIL VARCHAR2(50),
    MEM_DATE DATE NOT NULL
);

INSERT INTO MEM_NOTNULL VALUES(1,'USER01','PASS01','윤의진','남','010-1111-2222','aaa@naver.com','25/06/05');
INSERT INTO MEM_NOTNULL(MEM_NO,MEM_ID,MEM_PWD,MEM_NAME,MEM_DATE) VALUES(2,'USER02','PASS02','이진용',SYSDATE);
SELECT * FROM MEM_NOTNULL;

/*
    UNIQUE 제약조건
    - 해당 컬럼에 붕복된 값이 들어와서는 안 되는 경우
    - 컬럼값에 중복값을 제한하는 제약조건
    - 추가/ 수정 시 기존에 있는 데이터 값 중 중복값이 있을 경우 오류
*/

CREATE TABLE MEM_UNIQUE(
    MEM_NO NUMBER NOT NULL,
    MEM_ID VARCHAR2(20) NOT NULL UNIQUE,
    MEM_PWD VARCHAR2(20) NOT NULL,
    MEM_NAME VARCHAR2(20) NOT NULL,
    GENDER CHAR(3),
    PHONE VARCHAR2(13),
    EMAIL VARCHAR2(50),
    MEM_DATE DATE NOT NULL
);

INSERT INTO MEM_UNIQUE VALUES(1,'USER01','PASS01','윤의진','남','010-1111-2222','aaa@naver.com','25/06/05');
INSERT INTO MEM_UNIQUE(MEM_NO,MEM_ID,MEM_PWD,MEM_NAME,MEM_DATE) VALUES(2,'USER02','PASS02','이진용',SYSDATE);
INSERT INTO MEM_UNIQUE(MEM_NO,MEM_ID,MEM_PWD,MEM_NAME,GENDER,MEM_DATE) VALUES(3,'USER03','PASS03','곽병현','ㅇ',SYSDATE);
SELECT * FROM MEM_UNIQUE;

/*
    CHECK(조건식) 제약조건
    - 해당 컬럼에 들어올 수 있는 값에 대한 조건을 제시해볼 수 있음
    - 해당 조건에 만족하는 데이터갑만 담길 수 있음
*/
DROP TABLE MEM_CHECK;
CREATE TABLE MEM_CHECK(
    MEM_NO NUMBER NOT NULL,
    MEM_ID VARCHAR2(20) NOT NULL UNIQUE,
    MEM_PWD VARCHAR2(20) NOT NULL,
    MEM_NAME VARCHAR2(20) NOT NULL,
    GENDER CHAR(3) CHECK(GENDER IN('남','여')) NOT NULL,
    PHONE VARCHAR2(13),
    EMAIL VARCHAR2(50) CHECK(EMAIL LIKE '%@%'),
    MEM_DATE DATE NOT NULL
);

INSERT INTO MEM_CHECK VALUES(1,'USER01','PASS01','윤의진','남','010-1111-2222','aaa@naver.com','25/06/05');
INSERT INTO MEM_CHECK(MEM_NO,MEM_ID,MEM_PWD,MEM_NAME,MEM_DATE,GENDER) VALUES(2,'USER02','PASS02','이진용',SYSDATE,'남');
INSERT INTO MEM_CHECK(MEM_NO,MEM_ID,MEM_PWD,MEM_NAME,GENDER,MEM_DATE,EMAIL) VALUES(3,'USER03','PASS03','곽병현','남',SYSDATE,'bbb@google.com');
SELECT * FROM MEM_CHECK;

/*
    PRIMARY KEY(기본키) 제약조건
    - 테이블에서 각 행들을 식별하기 위해 사용될 컬럼에 부여하는 제약조건 (식별자 역할)
        EX) 회원번호, 학번, 사원번호, 부서코드, 직급코드, 주문번호, 예약번호,운송장번호
    - PRIMARY KEY 제약조건을 부여하면 그 컬럼은 자동으로 NOT NULL + UNIQUE 제약조건이 설정됨
    - 한 테이블 당 오로지 한개만 설정가능
*/
DROP TABLE MEM_PRI;
DROP SEQUENCE MEM_SEQ;
CREATE TABLE MEM_PRI(
    MEM_NO NUMBER PRIMARY KEY,
    MEM_ID VARCHAR2(20) NOT NULL UNIQUE,
    MEM_PWD VARCHAR2(20) NOT NULL,
    MEM_NAME VARCHAR2(20) NOT NULL,
    GENDER CHAR(3) CHECK(GENDER IN('남','여')) NOT NULL,
    PHONE VARCHAR2(13),
    EMAIL VARCHAR2(50) CHECK(EMAIL LIKE '%@%'),
    MEM_DATE DATE NOT NULL
);
CREATE SEQUENCE MEM_SEQ START WITH 1 INCREMENT BY 1 NOCACHE NOCYCLE;

INSERT INTO MEM_PRI VALUES(MEM_SEQ.NEXTVAL,'USER01','PASS01','윤의진','남','010-1111-2222','aaa@naver.com','25/06/05');
INSERT INTO MEM_PRI(MEM_NO,MEM_ID,MEM_PWD,MEM_NAME,MEM_DATE,GENDER) VALUES(MEM_SEQ.NEXTVAL,'USER02','PASS02','이진용',SYSDATE,'남');
INSERT INTO MEM_PRI(MEM_NO,MEM_ID,MEM_PWD,MEM_NAME,GENDER,MEM_DATE,EMAIL) VALUES(MEM_SEQ.NEXTVAL,'USER03','PASS03','곽병현','남',SYSDATE,'bbb@google.com');
SELECT * FROM MEM_PRI;
-- PRIMARY KEY는 자동! SEQUENCE 사용

-- 오라클 예전 버전 X
CREATE TABLE MEM_PRI2(
    MEM_NO NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY ,
    MEM_ID VARCHAR2(20) NOT NULL UNIQUE,
    MEM_PWD VARCHAR2(20) NOT NULL,
    MEM_NAME VARCHAR2(20) NOT NULL,
    GENDER CHAR(3) CHECK(GENDER IN('남','여')) NOT NULL,
    PHONE VARCHAR2(13),
    EMAIL VARCHAR2(50) CHECK(EMAIL LIKE '%@%'),
    MEM_DATE DATE NOT NULL
);

INSERT INTO MEM_PRI2(MEM_ID,MEM_PWD,MEM_NAME,GENDER,PHONE,EMAIL,MEM_DATE) VALUES('USER01','PASS01','윤의진','남','010-1111-2222','aaa@naver.com','25/06/05');
INSERT INTO MEM_PRI2(MEM_ID,MEM_PWD,MEM_NAME,MEM_DATE,GENDER) VALUES('USER02','PASS02','이진용',SYSDATE,'남');
INSERT INTO MEM_PRI2(MEM_ID,MEM_PWD,MEM_NAME,GENDER,MEM_DATE,EMAIL) VALUES('USER03','PASS03','곽병현','남',SYSDATE,'bbb@google.com');
SELECT * FROM MEM_PRI2;

-- 회원등급에 대한 데이터를 보관하는 테이블
DROP TABLE MEM_GRADE;
CREATE TABLE MEM_GRADE(
    GRADE_CODE NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    GRADE_NAME VARCHAR2(30) NOT NULL
);
INSERT INTO MEM_GRADE(GRADE_NAME) VALUES('일반회원');
INSERT INTO MEM_GRADE(GRADE_NAME) VALUES('우수회원');
INSERT INTO MEM_GRADE(GRADE_NAME) VALUES('특별회원');

SELECT * FROM MEM_GRADE;

CREATE TABLE MEM_MEMBER(
    MEM_NO NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY ,
    MEM_ID VARCHAR2(20) NOT NULL UNIQUE,
    MEM_PWD VARCHAR2(20) NOT NULL,
    MEM_NAME VARCHAR2(20) NOT NULL,
    GRADE_ID NUMBER -- 회원등급번호 보관할 컬럼
);

INSERT INTO MEM_MEMBER(MEM_ID,MEM_PWD,MEM_NAME,GRADE_ID) VALUES('USER01','PASS01','윤의진',1);
INSERT INTO MEM_MEMBER(MEM_ID,MEM_PWD,MEM_NAME,GRADE_ID) VALUES('USER02','PASS02','이진용',2);
INSERT INTO MEM_MEMBER(MEM_ID,MEM_PWD,MEM_NAME,GRADE_ID) VALUES('USER03','PASS03','곽병현',10);
SELECT * FROM MEM_MEMBER;

SELECT * 
FROM MEM_MEMBER 
LEFT JOIN MEM_GRADE ON GRADE_ID = GRADE_CODE; 

/*
    FOREIGN KEY (외래키)
    - 외래키 역할을 하는 컬럼에 부여하는 제약조건
    - 다른 테이블에 존재하는 값만 들어와야 되는 특정 컬럼에 부여하는 제약조건
    
    --> 다른 테이블을 참조한다고 표현
    --> 주로 FOREIGN KEY 제약조건에 의해 테이블 간의 관계가 형성
*/

DROP TABLE MEM_MEMBER2;
CREATE TABLE MEM_MEMBER2(
    MEM_NO NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY ,
    MEM_ID VARCHAR2(20) NOT NULL UNIQUE,
    MEM_PWD VARCHAR2(20) NOT NULL,
    MEM_NAME VARCHAR2(20) NOT NULL,
    GRADE_ID NUMBER REFERENCES MEM_GRADE(GRADE_CODE)-- 외래키
);

INSERT INTO MEM_MEMBER2(MEM_ID,MEM_PWD,MEM_NAME,GRADE_ID) VALUES('USER01','PASS01','윤의진',1);
INSERT INTO MEM_MEMBER2(MEM_ID,MEM_PWD,MEM_NAME,GRADE_ID) VALUES('USER02','PASS02','이진용',2);
INSERT INTO MEM_MEMBER2(MEM_ID,MEM_PWD,MEM_NAME,GRADE_ID) VALUES('USER03','PASS03','곽병현',3);
SELECT * FROM MEM_MEMBER2;

SELECT * 
FROM MEM_MEMBER2 
JOIN MEM_GRADE ON GRADE_ID = GRADE_CODE;

-- MEM_MEMBER2(자식테이블)-->---|- MEM_GRADE(부모테이블)

-- 데이터 삭제 : DELETE FROM 테이블명 WHERE 조건;
-- MEM_GRADE 테이블에서 GRADE_CODE가 1인 걸 삭제
DELETE FROM MEM_GRADE WHERE GRADE_CODE =1 ;

-- 부모테이블(MEM_GRADE에서 데이터 값을 삭제할 경우 문제 발생!)
-- 이유가 자식 레코드가 있어서 삭제되지 않음
DELETE FROM MEM_MEMBER2 WHERE MEM_NO = 1;

SELECT * FROM MEM_GRADE;
SELECT * FROM MEM_MEMBER2;
DROP TABLE MEM_MEMBER2;
DROP TABLE MEM_GRADE;


/*
    자식테이블 생성시 외래키 제약조건 부여할 때 삭제옵션 지정
    * 삭제옵션 : 부모테이블의 데이터 삭제 시 그 데이터를 사용하고 있는 자식테이블의 값을 어떻게 처리할지
    
    - ON DELETE RESTRICTED (기본값)
        : 자식데이터로 쓰이는 부모데이터는 삭제 아예 안되게끔
    - ON DELETE SET NULL
        : 부모데이터 삭제시 해당 데이터를 쓰고 있는 자식데이터의 값을 NULL로 변경
    - ON DELETE CASCADE
        : 부모데이터 삭제시 해당 데이터를 쓰고 있는 자식데이터도 같이 삭제시킴
*/

CREATE TABLE MEM_GRADE(
    GRADE_CODE NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    GRADE_NAME VARCHAR2(30) NOT NULL
);
INSERT INTO MEM_GRADE(GRADE_NAME) VALUES('일반회원');
INSERT INTO MEM_GRADE(GRADE_NAME) VALUES('우수회원');
INSERT INTO MEM_GRADE(GRADE_NAME) VALUES('특별회원');
SELECT * FROM MEM_GRADE;

CREATE TABLE MEM_MEMBER2(
    MEM_NO NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY ,
    MEM_ID VARCHAR2(20) NOT NULL UNIQUE,
    MEM_PWD VARCHAR2(20) NOT NULL,
    MEM_NAME VARCHAR2(20) NOT NULL,
    GRADE_ID NUMBER,
    FOREIGN KEY (GRADE_ID) REFERENCES MEM_GRADE(GRADE_CODE) ON DELETE CASCADE-- 외래키
);

INSERT INTO MEM_MEMBER2(MEM_ID,MEM_PWD,MEM_NAME,GRADE_ID) VALUES('USER01','PASS01','윤의진',1);
INSERT INTO MEM_MEMBER2(MEM_ID,MEM_PWD,MEM_NAME,GRADE_ID) VALUES('USER02','PASS02','이진용',2);
INSERT INTO MEM_MEMBER2(MEM_ID,MEM_PWD,MEM_NAME,GRADE_ID) VALUES('USER03','PASS03','곽병현',3);
SELECT * FROM MEM_MEMBER2;

SELECT * 
FROM MEM_MEMBER2 
JOIN MEM_GRADE ON GRADE_ID = GRADE_CODE;

SELECT * FROM MEM_GRADE;
SELECT * FROM MEM_MEMBER2;

DELETE FROM MEM_GRADE WHERE GRADE_CODE =1;
DROP TABLE MEM_MEMBER2;
DROP TABLE MEM_GRADE;

/*
    DEFAULT 기본값
    - 제약조건 아님!
    - 컬럼을 선정하지 않고 INSERT 시 NULL이 아닌 기본값을 INSERT하고자 할때 세팅해둘 수 있는 값
    
*/
DROP TABLE MEMBER;
CREATE TABLE MEMBER(
    MEM_NO NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    MEM_NAME VARCHAR2(20) NOT NULL,
    MEM_AGE NUMBER DEFAULT 10,
    HOBBY VARCHAR2(20) DEFAULT '게임',
    ENROLL_DATE DATE DEFAULT SYSDATE
);

INSERT INTO MEMBER(MEM_NAME) VALUES('윤의진');
INSERT INTO MEMBER(MEM_NAME,MEM_AGE) VALUES('이진용',20);
INSERT INTO MEMBER(MEM_NAME,MEM_AGE,HOBBY) VALUES('이진용',20,'영화감상');

SELECT * FROM MEMBER;

-- 도서관리 프로그램 테이블들
-- 테이블명 : PUBLISHER
-- 컬럼 : PUB_NO - 숫자, 기본키
--       PUB_NAME - 문자 50, NULL 허용X
--       PHONE - 문자20

-- 테이블명: BOOK
-- 컬럼 : BK_NO -숫자,기본키
--       BK_TITLE - 문자50, NULL x
--      BK_AUTHOR 문자50, NULL x
--      PUB_NO - 숫자 외래키 PUBLISHER PUB_NO 삭제조건 CASCADE

-- 테이블명 : MEMBER 드랍한번하기
-- 컬럼 : MEMBER_NO - 숫자, 기본키
--      MEMBER_ID - 문자50, 중복허용x

-- 테이블명 : RENT 
-- 컬럼 : RENT_NO - 숫자 기본키
--        MEMBER_NO - 숫자,외래키 MEMBER MEMBER_NO 삭제조건 SET NULL
--        BK_NO -숫자 , 외래키 BOOK BK_NO 삭제조건 SET NULL
DROP TABLE PUBLISHER;
CREATE TABLE PUBLISHER(
    PUB_NO NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    PUB_NAME VARCHAR2(50) NOT NULL,
    PHONE VARCHAR2(20)
);

DROP TABLE BOOK;
CREATE TABLE BOOK(
    BK_NO NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    BK_TITLE VARCHAR2(50) NOT NULL,
    BK_AUTHOR VARCHAR2(50) NOT NULL,
    PUB_NO NUMBER,
    FOREIGN KEY(PUB_NO) REFERENCES PUBLISHER(PUB_NO) ON DELETE CASCADE
);

DROP TABLE MEMBER;
CREATE TABLE MEMBER(
    MEMBER_NO NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    MEMBER_ID VARCHAR2(50) UNIQUE
);

DROP TABLE RENT;
CREATE TABLE RENT(
    RENT_NO NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    MEMBER_NO NUMBER,
    BK_NO NUMBER,
    FOREIGN KEY(MEMBER_NO) REFERENCES MEMBER(MEMBER_NO) ON DELETE SET NULL,
    FOREIGN KEY(BK_NO) REFERENCES BOOK(BK_NO) ON DELETE SET NULL
);

INSERT INTO PUBLISHER(PUB_NAME,PHONE) VALUES('오재덕','010-1234-5123');
INSERT INTO PUBLISHER(PUB_NAME,PHONE) VALUES('오재득','010-1224-5123');
INSERT INTO PUBLISHER(PUB_NAME,PHONE) VALUES('덕재오','010-1254-5123');

INSERT INTO BOOK(BK_TITLE, BK_AUTHOR,PUB_NO) VALUES('책1','저자1',1);
INSERT INTO BOOK(BK_TITLE, BK_AUTHOR,PUB_NO) VALUES('책2','저자2',2);
INSERT INTO BOOK(BK_TITLE, BK_AUTHOR,PUB_NO) VALUES('책3','저자3',2);
INSERT INTO BOOK(BK_TITLE, BK_AUTHOR,PUB_NO) VALUES('책4','저자4',3);
INSERT INTO BOOK(BK_TITLE, BK_AUTHOR,PUB_NO) VALUES('책5','저자5',1);

INSERT INTO MEMBER(MEMBER_ID) VALUES('멤버1');
INSERT INTO MEMBER(MEMBER_ID) VALUES('멤버2');
INSERT INTO MEMBER(MEMBER_ID) VALUES('멤버3');
INSERT INTO MEMBER(MEMBER_ID) VALUES('멤버4');
INSERT INTO MEMBER(MEMBER_ID) VALUES('멤버5');
INSERT INTO MEMBER(MEMBER_ID) VALUES('멤버6');

INSERT INTO RENT(MEMBER_NO,BK_NO) VALUES(1,2);
INSERT INTO RENT(MEMBER_NO,BK_NO) VALUES(2,3);
INSERT INTO RENT(MEMBER_NO,BK_NO) VALUES(3,4);
INSERT INTO RENT(MEMBER_NO,BK_NO) VALUES(1,5);
INSERT INTO RENT(MEMBER_NO,BK_NO) VALUES(4,1);
INSERT INTO RENT(MEMBER_NO,BK_NO) VALUES(6,3);
INSERT INTO RENT(MEMBER_NO,BK_NO) VALUES(5,4);

SELECT RENT_NO, MEMBER_ID,BK_TITLE, BK_AUTHOR, PUB_NAME
FROM RENT R
JOIN MEMBER M ON M.MEMBER_NO = R.MEMBER_NO
JOIN BOOK B ON B.BK_NO = R.BK_NO
JOIN PUBLISHER P ON B.PUB_NO = P.PUB_NO;

SELECT * FROM RENT;
COMMIT;

